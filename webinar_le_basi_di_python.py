# -*- coding: utf-8 -*-
"""Webinar - Le basi di Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JSpVWzg7ZAhPlIVTDEa5f2mqSFl6QJ0q

# Le basi di Python

Materiale per il webinar "Le basi di Python" della Dataninja School: [school.dataninja.it/courses/le-basi-di-python-in-2-ore](https://school.dataninja.it/courses/le-basi-di-python-in-2-ore).

> Python identifica i blocchi di codice annidati mediante indentazione (tabulazioni `	` e spazi `  `) e non usa invece delimitatori espliciti (es. parentesi graffe `{ ... }`).

> Nella sua evoluzione Python è giunto alla versione v3, ma ancora ci sono molti vecchi programmi e script scritti in Python v2. Al momento la versione più recente è la v3.10.

> Manuale di stile ufficiale: [python.org/dev/peps/pep-0008](https://www.python.org/dev/peps/pep-0008/).

## Contenuti
- Tipi di dato
  - Stringa
  - Numero intero
  - Numero in virgola mobile
  - Valore di verità
  - Dato mancante
- Strutture dati
  - Lista
  - Tupla
  - Insieme
  - Dizionario
- Variabili
  - Dichiarazione e assegnazione
  - Accesso
  - Operazioni
  - Aggiornamento
  - Parsing e casting
- Controllo del flusso
  - Funzione
  - Ciclo
  - Condizione
  - List comprehension
  - Dict comprehension
- Librerie

## Tipi di dato

### Stringa (*string* o  *str*)

Una stringa è una sequenza di caratteri, iterabile, rappresentabili secondo una codifica data, solitamente `UTF-8`. In Python si delimita con le virgolette singole (`'`) o le doppie virgolette (`"`). La codifica predefinita è `UTF-8` (v3). Per approfondire: [it.wikipedia.org/wiki/Codifica_di_caratteri](https://it.wikipedia.org/wiki/Codifica_di_caratteri).
"""

"questa è un'altra stringa"

"""### Numero intero (*integer* o *int*)

Un numero intero, positivo o negativo, incluso lo zero. Per favorire la leggibilità si può scrivere usando il trattino basso (`_`) come separatore delle migliaia (>=v3.6). Per approfondire: [it.wikipedia.org/wiki/Numero_intero_(informatica)](https://it.wikipedia.org/wiki/Numero_intero_(informatica)).
"""

123_764_726_472_642

"""### Numero in virgola mobile (*floating point* o *float*)

Un numero razionale, positivo o negativo, incluso lo zero. Si usa la notazione anglosassone che prevede il punto (`.`) come separatore dei decimali. Per favorire la leggibilità si può scrivere usando il trattino basso (`_`) come separatore delle migliaia (>=v3.6). Per approfondire: [it.wikipedia.org/wiki/Numero_in_virgola_mobile](https://it.wikipedia.org/wiki/Numero_in_virgola_mobile).
"""

123_764.72

"""### Valore di verità (*boolean*)

Sono ammessi solo due valori booleani: `True` e `False` (vero e falso), scritti in inglese con l'iniziale maiuscola. Per approfondire: [it.wikipedia.org/wiki/Variabile_booleana](https://it.wikipedia.org/wiki/Variabile_booleana).
"""

True

False

"""### Dato mancante

Si può rappresentare il concetto di *nessun dato* con il tipo `None`.
"""

None

"""## Strutture dati

### Lista (*list*)

Una collezione ordinata di dati, iterabile. Una volta definita, può essere modificata (es. si può aggiungere un elemento in coda). Una stessa lista può contenere tipi diversi di dati (es. numeri e stringhe). Si delimita con le parentesi quadre `[...]`, mentre gli elementi sono separati da una virgola `,`. Può essere scritta su più righe opportunamente indentate.
"""

[1, 2, 3]

[
    "uno",
    2,
    False
]

"""### Tupla (*tuple*)

Una collezione ordinata di dati, iterabile. Una volta definita, non può essere modificata. Una stessa tupla può contenere tipi diversi di dati (es. numeri e stringhe). Si delimita con le parentesi tonde `(...)`, mentre gli elementi sono separati da una virgola `,`. Può essere scritta su più righe opportunamente indentate.
"""

(1, 2, 3)

(
    "uno",
    2,
    False
)

"""### Insieme (*set*)

Una collezione non ordinata di dati, iterabile, i cui valori sono unici, possono comparire solo una volta. Dopo essere stato definito, può essere modificato. Uno stesso set può contenere tipi diversi di dati (es. numeri e stringhe) purché *hashable* (rappresentabili da stringhe). Si delimita con le parentesi graffe `{...}`, mentre gli elementi sono separati da una virgola `,`. Può essere scritta su più righe opportunamente indentate.
"""

{1, 2, 2, 3}

{
    "uno",
    2,
    False,
    False
}

"""### Dizionario (*dict*)

Una collezione non ordinata di *coppie chiave / valore*. Una volta definito, può essere modificato (es. si può aggiungere una nuova chiave con il suo valore). Uno stesso dizionario può contenere tipi diversi di dati (es. numeri e stringhe) come valori, ma solo elementi *hashable* (rappresentabili da stringhe) come chiavi. Si delimita con le parentesi graffe `{...}`, le coppie sono separate da una virgola `,` e la chiave dal valore dai due punti `:`. Può essere scritta su più righe opportunamente indentate.
"""

{
    "nome": "Alessio",
    "anno": 1983
}

"""## Variabili

### Dichiarazione e assegnazione

Una variabile è composta di due parti: il nome e il valore. Ci sono delle restrizioni nei nomi utilizzabili per le variabili (es. non possono contenere spazi).

Il primo uso di una variabile ne implica la dichiarazione. Per assegnarle un valore si usa l'uguale `=`: a sinistra la variabile, a destra il nuovo valore. Assegnazioni successive cancellano i valori precedenti.
"""

my_name = "Alessio"

my_name

"""### Accesso

Quando una variabile dichiarata e con un valore assegnato viene nominata, verrà sostituita dal suo valore corrispondente durante l'esecuzione.

Per accedere ai singoli elementi di una struttura dati (escluso il set) o ai caratteri di una stringa si usano le parentesi quadre `[...]` per delimitare l'indice di riferimento. Per un iterabile l'indice parte da `0` (primo elemento) oppure è una chiave per un dizionario.

Mediante lo *slicing* è possibile anche accedere a un sottoinsieme degli elementi di un iterabile (tranne il set).
"""

my_list = [1, 2, 3, 4]
my_list[2]

my_list[1:3]

my_tuple = (1, 2, 3)
my_tuple[1]

my_string = "Alessio"
my_string[2]

my_dict = { "nome": "Alessio", "anno": 1983 }
my_dict["anno"]

"""### Operazioni

Si posso applicare operazioni di base ai valori delle variabili mediante operatori predefiniti che hanno un significato e un effetto in base al contesto, al tipo di variabile su cui agiscono.

Per esempio la somma `+` effettua una somma sui numeri, ma una concatenazione sulle stringhe e le liste.

Per quanto riguarda le operazioni aritmetiche:
- `+` somma
- `-` differenza
- `*` moltiplicazione
- `/` divisione
- `**` elevazione a potenza
- `//` parte intera della divisione
- `%` resto intero della divisione

Per quanto riguarda i confronti logici:
- `==` uguale
- `>` maggiore
- `>=` maggiore uguale
- `<` minore
- `=<` minore uguale
- `!=` diverso
- `in` è contenuto in
- `is` sono lo stesso oggetto

E i connettori logici:
- `not` NOT
- `and` AND
- `or` OR
- `^` XOR
"""

oranges = 8
apples = 4

fruits = oranges + apples

fruits

first_name = "Caterina"
second_name = "Guzzanti"
full_name = first_name + " " + second_name
full_name

first_list = [1, 2, 3]
second_list = [4, 5, 6]
full_list = first_list + second_list
full_list

"""### Aggiornamento

Una struttura dati contenuta in una variabile può essere modificata senza essere sovrascritta. Per esempio liste e tuple hanno metodi per aggiungere un elemento in coda, toglierne uno dall'inizio, ecc.

I metodi hanno nomi specifici (es. `append`), sono separati dalla variabile mediante un punto `.` e accettano argomenti tra parentesi tonde `(...)`.

Gli operatori di base possono essere combinati con un'assegnazione per ottenere un aggiornamento del valore di una variabile:
- `+=` somma
- `-=` differenza
- `*=` moltiplicazione
- `/=` divisione
- `**=` elevazione a potenza
- `//=` parte intera della divisione
- `%=` resto intero della divisione

"""

l = [1, 2, 3]
l += [4]
l.append(5)
l

s = "Forza 4"
s += "2"
s

"""### Da un tipo di dato a un altro: parsing e casting

In alcuni casi è possibile passare da un tipo di dato a un altro.

Per esempio se abbiamo una stringa composta da sole cifre, possiamo farla interpretare come numero intero. Questa operazione si chiama *parsing*.

Possiamo anche forzare la conversione da un tipo a un altro, per esempio trasformare un numero decimale in un numero intero (perdendo l'informazione delle cifre decimali), oppure creare una lista da una tupla o un set. Questa operazione si chiama *casting*.

Quando si effettua il casting con un valore booleano ci sono delle regole precise che indicano se un valore è *falsy* (valutato falso) o *truthy* (valutato vero).
"""

# Parsing: from string to native type
integer_as_string = "42"
integer_as_integer = int(integer_as_string)
integer_as_integer

# Casting: from type to type
floating_number = 42.0001
integer_number = int(floating_number)
integer_number

# *Truthy* and *Falsy* values
falsy_values = ["", 0, False, [], (), {}, None, "ciao", 42]
list(map(bool, falsy_values))

"""## Controllo del flusso

### Funzione (*function*)

Una funzione è come una variabile che contiene istruzioni eseguibili. Può avere un nome e contiene un blocco di codice che viene eseguito quando nominata. Può accettare dei valori in input come argomenti e ritornare valori in output.

Alcune funzioni sono già definite nella libreria standard del linguaggio ([built-in functions](https://docs.python.org/3/library/functions.html)), altre possono essere definite a nostro piacimento.

Tutti i tipi di dato hanno una serie di metodi utili che non sono altro che funzioni, accessibili con la *dot notation* (es. `list.append(element)`).

Definizione ed esecuzione di una funzione denominata (*named function*).
"""

# Custom definition of a named function
def sum_two_fruits(fruit1, fruit2):
    return fruit1 + fruit2

sum_two_fruits(1, 10)

# `sum` is a built-in function, takes an iterable and sums all elements
items = [1,2,3,2,1,3,4,5,6,7]
how_many_items = sum(items)
how_many_items

# `print` is a built-in function, takes a variable and prints out its value
full_name = "Alessio Cimarelli"
print(full_name)

"""Definizione ed esecuzione di una funzione anonima (*lambda*)."""

#def double(n):
#  return n * 2

items = [1,2,3,2,1]
#doubled_items = map(double, items)
doubled_items = map(lambda n: n * 2, items)
list(doubled_items)
# `map` is a built-int function, takes a function and an iterable and applies the function to all elements of the iterable

"""### Ciclo (*loop*)

Un ciclo permette di eseguire più volte lo stesso blocco di codice. Per esempio per ogni elemento di un iterabile o per un numero fisso di volte.
"""

items = [1, 2, 3, 4]
for item in items:
    print(item)

items = [1,2,3,2,1]
how_many_items = 0

for item in items:
    how_many_items += item

how_many_items

items = [1,2,3,2,1]
doubled_items = []

for item in items:
    doubled_items.append(item * 2)

doubled_items

my_dict = { "nome": "Alessio", "anno": 1983 }
for key in my_dict:
    print(key, ":", my_dict[key])

"""### Condizione (*if*)

Il costrutto *if* permette di eseguire un blocco di istruzioni in base al verificarsi di una condizione. Può far parte di un ciclo o della definizione di una funzione.

Python permette di definire un blocco *if* anche in linea.
"""

item1 = 34
item2 = 2
threshold = 5

print(item1 > threshold)
if item1 > threshold:
    print(item1)
else:
    print("-")

print(item2 > threshold)
if item2 > threshold:
    print(item2)
else:
    print("-")

print(
    item2
    if item2 > threshold
    else "-"
)

"""### List comprehension

Python ha un meccanismo peculiare e molto versatile per costruire iterabili a partire da un ciclo ed eventualmente da una condizione.
"""

items = [1,2,3,2,1]
#doubled_items = map(lambda n: n * 2, items)
doubled_items = [item * 2 for item in items if item > 1]
doubled_items

"""### Dict comprehension

Lo stesso meccanismo funziona anche per i dizionari.
"""

items = [ "first_name:Alessio", "second_name:Cimarelli", "city:Padua" ]
items_as_dict = {
    item.split(":")[0]: item.split(":")[1]
    for item in items
    if "_name" in item
}
items_as_dict

"""## Librerie

Normalmente il codice sorgente di un programma è scritto e salvato in un file di testo. Python mette a disposizione un meccanismo per importare porzioni di codice da file esterni. Così è possibile scrivere codice, condividerlo con licenza open source e riutilizzarlo liberamente.

Qualunque codice scritto e distribuito appositamente per essere importato in altri programmi e non eseguito direttamente prende il nome di *libreria*. La [libreria standard di Python](https://docs.python.org/3/library/) mette a disposizione moltissime utilità pronte per essere utilizzate.

Il [Python Package Index (PyPI)](https://pypi.org/) è un archivio di pacchetti liberamente accessibili che possono essere scaricati, installati e importati come librerie aggiuntive. Lo strumento ufficiale per effetturare queste operazioni è [pip](https://pip.pypa.io/en/stable/).

### Math

Utilità matematiche avanzate. Documentazione ufficiale: [docs.python.org/3/library/math.html](https://docs.python.org/3/library/math.html).
"""

import math
print(math.exp(2))

from math import exp
print(exp(2))

from math import exp as esponenziale
print(esponenziale(2))

"""### Pandas

Una delle librerie più usate per l'analisi dati in progetti di data science. Sito ufficiale: [pandas.pydata.org](https://pandas.pydata.org/).
"""

# Import main library
import pandas as pd
# Just a workaround to globally set chart sizes
import matplotlib.pyplot as plt
plt.rcParams['figure.figsize'] = [35, 15]

# Import data from official open data by Protezione Civile
data = pd.read_csv(
    "https://github.com/pcm-dpc/COVID-19/raw/master/dati-andamento-nazionale/dpc-covid19-ita-andamento-nazionale.csv",
    index_col = "data",
    parse_dates = True
)

# Data preview
data

# Line chart of `totale_positivi`
data.plot.line(y = "totale_positivi")

# Weekly moving average of `nuovi_positivi`
data["nuovi_positivi_avg"] = data["nuovi_positivi"].rolling(7).mean()

# Double lines chart of `totale_positivi` (daily and weekly)
data.plot.line(y = ["nuovi_positivi", "nuovi_positivi_avg"])